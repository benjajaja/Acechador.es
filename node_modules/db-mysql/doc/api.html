<a href="http://github.com/mariano/node-drizzle"><img alt="Fork me on GitHub" id="ribbon" src="http://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"></a><html>
	<head>
		<title>Node-drizzle API</title>
		<script src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"></script>
		<style>body {
    margin: 0;
    padding: 0;
    font: 14px/1.5 'Palatino Linotype', 'Book Antiqua', Palatino, FreeSerif, serif;
    color: #252519;
}
a {
    color: #252519;
}
a:hover {
    text-decoration: underline;
    color: #19469D;
}
p {
    margin: 12px 0;
}
h1, h2, h3 {
    margin: 0;
    padding: 0;
}
table#source {
    width: 100%;
    border-collapse: collapse;
}
table#source td:first-child {
    padding: 30px 40px 30px 40px;
    vertical-align: top;
}
table#source td:first-child,
table#source td:first-child pre {
    width: 450px;
}
table#source td:last-child {
    padding: 30px 0 30px 40px;
    border-left: 1px solid #E5E5EE;
    background: #F5F5FF;
}
table#source tr {
    border-bottom: 1px solid #E5E5EE;
}
table#source tr.filename {
    padding-top: 40px;
    border-top: 1px solid #E5E5EE;
}
table#source tr.filename td:first-child {
    text-transform: capitalize;
}
table#source tr.filename td:last-child {
    font-size: 12px;
}
table#source tr.filename h2 {
    margin: 0;
    padding: 0;
    cursor: pointer;
}
table#source tr.code h1,
table#source tr.code h2,
table#source tr.code h3 {
    margin-top: 30px;
    font-family: "Lucida Grande", "Helvetica Nueue", Arial, sans-serif;
    font-size: 18px;
}
table#source tr.code h2 {
    font-size: 16px;
}
table#source tr.code h3 {
    font-size: 14px;
}
table#source tr.code ul {
    margin: 15px 0 15px 35px;
    padding: 0;
}
table#source tr.code ul li {
    margin: 0;
    padding: 1px 0;
}
table#source tr.code ul li p {
    margin: 0;
    padding: 0;
}
table#source tr.code td:first-child pre {
    padding: 20px;
}
#ribbon {
    position: fixed;
    top: 0;
    right: 0;
}
code .string { color: #219161; }
code .regexp { color: #219161; }
code .keyword { color: #954121; }
code .number { color: #19469D; }
code .comment { color: #bbb; }
code .this { color: #19469D; }</style>
		<script>
			$(function(){
				$('tr.code').hide();
				$('tr.filename').toggle(function(){
					$(this).nextUntil('.filename').fadeIn();
				}, function(){
					$(this).nextUntil('.filename').fadeOut();
				});
			});
		</script>
	</head>
	<body>
<table id="source"><tbody><tr><td><h1>Node-drizzle API</h1><p>Drizzle/MySQL bindings for <a href="http://nodejs.org">Node.js</a> using libdrizzle.</p>

<p>Check out the <a href="http://github.com/mariano/node-drizzle">Github repo</a> for the source and installation guide.</p>

<p>Extra information: <a href="./index.html">Homepage</a>, <a href="./changelog.html">ChangeLog</a>, <a href="./examples.html">Examples</a>, <a href="http://github.com/mariano/node-drizzle/wiki">Wiki</a>.</p></td><td></td></tr><tr class="filename"><td><h2 id="./src/drizzle/connection.h"><a href="#">connection.h</a></h2></td><td>./src/drizzle/connection.h</td></tr><tr class="code">
<td class="docs">
<p>// Copyright 2011 Mariano Iglesias <a href="mailto:mgiglesias@gmail.com">mgiglesias@gmail.com</a>
#ifndef SRC<em>DRIZZLE</em>CONNECTION<em>H</em>
#define SRC<em>DRIZZLE</em>CONNECTION<em>H</em></p>

<h1>include &lt;libdrizzle/drizzle.h&gt;</h1>

<h1>include &lt;libdrizzle/drizzle_client.h&gt;</h1>

<h1>include &lt;string&gt;</h1>

<h1>include "./exception.h"</h1>

<h1>include "./result.h"</h1>

<p>namespace drizzle {
class Connection {
    public:
        Connection();
        ~Connection();
        std::string getHostname() const;
        void setHostname(const std::string&amp; hostname);
        std::string getUser() const;
        void setUser(const std::string&amp; user);
        std::string getPassword() const;
        void setPassword(const std::string&amp; password);
        std::string getDatabase() const;
        void setDatabase(const std::string&amp; database);
        uint32<em>t getPort() const;
        void setPort(uint32</em>t port);
        bool isMysql() const;
        void setMysql(bool mysql);
        bool isOpened() const;
        void open() throw(Exception&amp;);
        void close();
        std::string escape(const std::string&amp; string) const throw(Exception&amp;);
        std::string version() const;
        Result* query(const std::string&amp; query) const throw(Exception&amp;);</p>

<pre><code>protected:
    std::string hostname;
    std::string user;
    std::string password;
    std::string database;
    uint32_t port;
    bool mysql;
    bool opened;

private:
    drizzle_st* drizzle;
    drizzle_con_st* connection;</code></pre>

<p>};
}</p>

<h1>endif  // SRC_DRIZZLE_CONNECTION_H_</h1>
</td>
<td class="code">

</td>
</tr><tr class="filename"><td><h2 id="./src/drizzle/connection.cc"><a href="#">connection.cc</a></h2></td><td>./src/drizzle/connection.cc</td></tr><tr class="code">
<td class="docs">
<p>// Copyright 2011 Mariano Iglesias <a href="mailto:mgiglesias@gmail.com">mgiglesias@gmail.com</a>
#include "./connection.h"</p>

<p>drizzle::Connection::Connection()
    :port(3306),
    mysql(true),
    opened(false),
    drizzle(NULL),
    connection(NULL) {
}</p>

<p>drizzle::Connection::~Connection() {
    this-&gt;close();
    if (this-&gt;drizzle != NULL) {
        drizzle_free(this-&gt;drizzle);
    }
}</p>

<p>std::string drizzle::Connection::getHostname() const {
    return this-&gt;hostname;
}</p>

<p>void drizzle::Connection::setHostname(const std::string&amp; hostname) {
    this-&gt;hostname = hostname;
}</p>

<p>std::string drizzle::Connection::getUser() const {
    return this-&gt;user;
}</p>

<p>void drizzle::Connection::setUser(const std::string&amp; user) {
    this-&gt;user = user;
}</p>

<p>std::string drizzle::Connection::getPassword() const {
    return this-&gt;password;
}</p>

<p>void drizzle::Connection::setPassword(const std::string&amp; password) {
    this-&gt;password = password;
}</p>

<p>std::string drizzle::Connection::getDatabase() const {
    return this-&gt;database;
}</p>

<p>void drizzle::Connection::setDatabase(const std::string&amp; database) {
    this-&gt;database = database;
}</p>

<p>uint32_t drizzle::Connection::getPort() const {
    return this-&gt;port;
}</p>

<p>void drizzle::Connection::setPort(uint32_t port) {
    this-&gt;port = port;
}</p>

<p>bool drizzle::Connection::isMysql() const {
    return this-&gt;mysql;
}</p>

<p>void drizzle::Connection::setMysql(bool mysql) {
    this-&gt;mysql = mysql;
}</p>

<p>bool drizzle::Connection::isOpened() const {
    return this-&gt;opened;
}</p>

<p>void drizzle::Connection::open() throw(drizzle::Exception&amp;) {
    this-&gt;close();</p>

<pre><code>if (this-&gt;drizzle == NULL) {
    this-&gt;drizzle = drizzle_create(NULL);
    if (this-&gt;drizzle == NULL) {
        throw drizzle::Exception("Cannot create drizzle structure");
    }

    drizzle_add_options(this-&gt;drizzle, DRIZZLE_NON_BLOCKING);
}

this-&gt;connection = drizzle_con_create(this-&gt;drizzle, NULL);
if (this-&gt;connection == NULL) {
    throw drizzle::Exception("Cannot create connection structure");
}

drizzle_con_set_tcp(this-&gt;connection, this-&gt;hostname.c_str(), this-&gt;port);
drizzle_con_set_auth(this-&gt;connection, this-&gt;user.c_str(), this-&gt;password.c_str());
drizzle_con_set_db(this-&gt;connection, this-&gt;database.c_str());
if (this-&gt;mysql) {
    drizzle_con_add_options(this-&gt;connection, DRIZZLE_CON_MYSQL);
}

drizzle_return_t result;
try {
    while (!this-&gt;opened) {
        result = drizzle_con_connect(this-&gt;connection);
        if (result == DRIZZLE_RETURN_OK) {
            this-&gt;opened = true;
            break;
        } else if (result != DRIZZLE_RETURN_IO_WAIT) {
            throw drizzle::Exception(drizzle_con_error(this-&gt;connection));
        }

        if (drizzle_con_wait(this-&gt;drizzle) != DRIZZLE_RETURN_OK) {
            throw drizzle::Exception("Could not wait for connection");
        }

        if (drizzle_con_ready(this-&gt;drizzle) == NULL) {
            throw drizzle::Exception("Could not fetch connection");
        }
    }
} catch(...) {
    if (this-&gt;connection != NULL) {
        drizzle_con_free(this-&gt;connection);
        this-&gt;opened = false;
        this-&gt;connection = NULL;
    }
    throw;
}</code></pre>

<p>}</p>

<p>void drizzle::Connection::close() {
    if (this-&gt;connection != NULL) {
        drizzle<em>con</em>close(this-&gt;connection);
        drizzle<em>con</em>free(this-&gt;connection);
        this-&gt;connection = NULL;
    }
    this-&gt;opened = false;
}</p>

<p>std::string drizzle::Connection::escape(const std::string&amp; string) const throw(drizzle::Exception&amp;) {
    char* buffer = new char[string.length() * 2 + 1];
    if (buffer == NULL) {
        throw drizzle::Exception("Can\'t create buffer to escape string");
    }</p>

<pre><code>drizzle_escape_string(buffer, string.c_str(), string.length());

std::string escaped = buffer;
delete [] buffer;
return escaped;</code></pre>

<p>}</p>

<p>std::string drizzle::Connection::version() const {
    std::string version;
    if (this-&gt;opened) {
        version = drizzle<em>con</em>server_version(this-&gt;connection);
    }
    return version;
}</p>

<p>drizzle::Result* drizzle::Connection::query(const std::string&amp; query) const throw(drizzle::Exception&amp;) {
    if (!this-&gt;opened) {
        throw drizzle::Exception("Can't execute query without an opened connection");
    }</p>

<pre><code>drizzle_result_st *result = NULL;
drizzle_return_t executed;
try {
    while (true) {
        result = drizzle_query(this-&gt;connection, NULL, query.c_str(), query.length(), &amp;executed);

        if (executed == DRIZZLE_RETURN_OK) {
            break;
        } else if (executed != DRIZZLE_RETURN_IO_WAIT) {
            if (executed == DRIZZLE_RETURN_LOST_CONNECTION) {
                throw drizzle::Exception("Lost connection while executing query");
            }
            throw drizzle::Exception(drizzle_con_error(this-&gt;connection));
        }

        if (drizzle_con_wait(this-&gt;drizzle) != DRIZZLE_RETURN_OK) {
            throw drizzle::Exception("Could not wait for connection");
        }

        if (drizzle_con_ready(this-&gt;drizzle) == NULL) {
            throw drizzle::Exception("Could not fetch connection");
        }
    }
} catch(...) {
    if (result != NULL) {
        drizzle_result_free(result);
    }
    throw;
}

if (result == NULL) {
    throw drizzle::Exception("Could not fetch result of query");
}

return new drizzle::Result(this-&gt;drizzle, result);</code></pre>

<p>}</p>
</td>
<td class="code">

</td>
</tr><tr class="filename"><td><h2 id="./src/drizzle/exception.h"><a href="#">exception.h</a></h2></td><td>./src/drizzle/exception.h</td></tr><tr class="code">
<td class="docs">
<p>// Copyright 2011 Mariano Iglesias <a href="mailto:mgiglesias@gmail.com">mgiglesias@gmail.com</a>
#ifndef SRC<em>DRIZZLE</em>EXCEPTION<em>H</em>
#define SRC<em>DRIZZLE</em>EXCEPTION<em>H</em></p>

<h1>include &lt;exception&gt;</h1>

<p>namespace drizzle {
class Exception : public std::exception {
    public:
        explicit Exception(const char<em> message);
        const char</em> what() const throw();
    protected:
        const char* message;
};
}</p>

<h1>endif  // SRC_DRIZZLE_EXCEPTION_H_</h1>
</td>
<td class="code">

</td>
</tr><tr class="filename"><td><h2 id="./src/drizzle/exception.cc"><a href="#">exception.cc</a></h2></td><td>./src/drizzle/exception.cc</td></tr><tr class="code">
<td class="docs">
<p>// Copyright 2011 Mariano Iglesias <a href="mailto:mgiglesias@gmail.com">mgiglesias@gmail.com</a>
#include "./exception.h"</p>

<p>drizzle::Exception::Exception(const char* message) : exception(),
    message(message) {
}</p>

<p>const char* drizzle::Exception::what() const throw() {
    return this-&gt;message;
}</p>
</td>
<td class="code">

</td>
</tr><tr class="filename"><td><h2 id="./src/drizzle/result.h"><a href="#">result.h</a></h2></td><td>./src/drizzle/result.h</td></tr><tr class="code">
<td class="docs">
<p>// Copyright 2011 Mariano Iglesias <a href="mailto:mgiglesias@gmail.com">mgiglesias@gmail.com</a>
#ifndef SRC<em>DRIZZLE</em>RESULT<em>H</em>
#define SRC<em>DRIZZLE</em>RESULT<em>H</em></p>

<h1>include &lt;libdrizzle/drizzle.h&gt;</h1>

<h1>include &lt;libdrizzle/drizzle_client.h&gt;</h1>

<h1>include &lt;string&gt;</h1>

<h1>include &lt;stdexcept&gt;</h1>

<h1>include "./exception.h"</h1>

<p>namespace drizzle {
class Result {
    public:
        class Column {
            public:
                typedef enum {
                    STRING,
                    TEXT,
                    INT,
                    NUMBER,
                    DATE,
                    TIME,
                    DATETIME,
                    BOOL,
                    SET
                } type_t;</p>

<pre><code>            explicit Column(drizzle_column_st *column);
            ~Column();
            std::string getName() const;
            type_t getType() const;

        protected:
            std::string name;
            type_t type;
    };

    explicit Result(drizzle_st* drizzle, drizzle_result_st* result) throw(Exception&amp;);
    ~Result();
    bool hasNext() const;
    const char** next() throw(Exception&amp;);
    uint64_t index() const throw(std::out_of_range&amp;);
    Column* column(uint16_t i) const throw(std::out_of_range&amp;);
    uint64_t insertId() const;
    uint64_t affectedCount() const;
    uint16_t warningCount() const;
    uint16_t columnCount() const;

protected:
    Column **columns;
    uint16_t totalColumns;
    uint64_t rowNumber;

    char **row() throw(Exception&amp;);

private:
    drizzle_st *drizzle;
    drizzle_result_st *result;
    drizzle_row_t previousRow;
    drizzle_row_t nextRow;</code></pre>

<p>};
}</p>

<h1>endif  // SRC_DRIZZLE_RESULT_H_</h1>
</td>
<td class="code">

</td>
</tr><tr class="filename"><td><h2 id="./src/drizzle.h"><a href="#">drizzle.h</a></h2></td><td>./src/drizzle.h</td></tr><tr class="code">
<td class="docs">
<p>// Copyright 2011 Mariano Iglesias <a href="mailto:mgiglesias@gmail.com">mgiglesias@gmail.com</a>
#ifndef SRC<em>DRIZZLE</em>H<em>
#define SRC</em>DRIZZLE<em>H</em></p>

<h1>include &lt;stdlib.h&gt;</h1>

<h1>include &lt;node.h&gt;</h1>

<h1>include &lt;node_buffer.h&gt;</h1>

<h1>include &lt;node_events.h&gt;</h1>

<h1>include &lt;string&gt;</h1>

<h1>include &lt;sstream&gt;</h1>

<h1>include &lt;vector&gt;</h1>

<h1>include "./drizzle/connection.h"</h1>

<h1>include "./drizzle/exception.h"</h1>

<h1>include "./drizzle/result.h"</h1>

<h1>include "./drizzle_bindings.h"</h1>

<p>namespace node_drizzle {
class Drizzle : public node::EventEmitter {
    public:
        static void Init(v8::Handle&lt;v8::Object&gt; target);</p>

<pre><code>protected:
    typedef enum {
        COLUMN_TYPE_STRING,
        COLUMN_TYPE_BOOL,
        COLUMN_TYPE_INT,
        COLUMN_TYPE_NUMBER,
        COLUMN_TYPE_DATE,
        COLUMN_TYPE_TIME,
        COLUMN_TYPE_DATETIME,
        COLUMN_TYPE_TEXT,
        COLUMN_TYPE_SET
    } column_type_t;
    struct connect_request_t {
        Drizzle* drizzle;
        const char* error;
        v8::Persistent&lt;v8::Function&gt; cbSuccess;
        v8::Persistent&lt;v8::Function&gt; cbError;
    };
    struct query_request_t {
        bool cast;
        bool buffer;
        Drizzle* drizzle;
        std::string query;
        drizzle::Result *result;
        const char* error;
        std::vector&lt;std::string**&gt;* rows;
        v8::Persistent&lt;v8::Function&gt; cbStart;
        v8::Persistent&lt;v8::Function&gt; cbFinish;
        v8::Persistent&lt;v8::Function&gt; cbSuccess;
        v8::Persistent&lt;v8::Function&gt; cbError;
        v8::Persistent&lt;v8::Function&gt; cbEach;
    };
    drizzle::Connection *connection;

    Drizzle();
    ~Drizzle();
    static v8::Handle&lt;v8::Value&gt; New(const v8::Arguments&amp; args);
    static v8::Handle&lt;v8::Value&gt; Connect(const v8::Arguments&amp; args);
    static v8::Handle&lt;v8::Value&gt; Disconnect(const v8::Arguments&amp; args);
    static v8::Handle&lt;v8::Value&gt; Escape(const v8::Arguments&amp; args);
    static v8::Handle&lt;v8::Value&gt; Query(const v8::Arguments&amp; args);
    static int eioConnect(eio_req* req);
    static void connect(connect_request_t* request);
    static void connectFinished(connect_request_t* request);
    static int eioConnectFinished(eio_req* eioRequest);
    static int eioQuery(eio_req* eioRequest);
    static int eioQueryFinished(eio_req* eioRequest);
    static int eioQueryEach(eio_req* eioRequest);
    static int eioQueryEachFinished(eio_req* eioRequest);
    static void eioQueryCleanup(query_request_t* request);
    static void eioQueryRequestFree(query_request_t* request);
    v8::Local&lt;v8::Object&gt; row(drizzle::Result* result, std::string** currentRow, bool cast) const;
    std::string parseQuery(const std::string&amp; query, v8::Local&lt;v8::Array&gt; values) const throw(drizzle::Exception&amp;);
    std::string value(v8::Local&lt;v8::Value&gt; value, bool inArray = false) const throw(drizzle::Exception&amp;);

private:
    uint64_t toDate(const std::string&amp; value, bool hasTime) const throw(drizzle::Exception&amp;);
    std::string fromDate(const uint64_t timeStamp) const throw(drizzle::Exception&amp;);
    uint64_t toTime(const std::string&amp; value) const;
    // GMT delta calculation borrowed from https://github.com/Sannis/node-mysql-libmysqlclient
    int gmtDelta() const throw(drizzle::Exception&amp;);</code></pre>

<p>};
}</p>

<h1>endif  // SRC_DRIZZLE_H_</h1>
</td>
<td class="code">

</td>
</tr><tr class="filename"><td><h2 id="./src/drizzle/result.cc"><a href="#">result.cc</a></h2></td><td>./src/drizzle/result.cc</td></tr><tr class="code">
<td class="docs">
<p>// Copyright 2011 Mariano Iglesias <a href="mailto:mgiglesias@gmail.com">mgiglesias@gmail.com</a>
#include "./result.h"</p>

<p>drizzle::Result::Column::Column(drizzle<em>column</em>st *column) {
    this-&gt;name = drizzle<em>column</em>name(column);</p>

<pre><code>switch (drizzle_column_type(column)) {
    case DRIZZLE_COLUMN_TYPE_TINY:
        this-&gt;type = (drizzle_column_size(column) == 1 ? BOOL : INT);
        break;
    case DRIZZLE_COLUMN_TYPE_BIT:
    case DRIZZLE_COLUMN_TYPE_SHORT:
    case DRIZZLE_COLUMN_TYPE_YEAR:
    case DRIZZLE_COLUMN_TYPE_INT24:
    case DRIZZLE_COLUMN_TYPE_LONG:
    case DRIZZLE_COLUMN_TYPE_LONGLONG:
        this-&gt;type = INT;
        break;
    case DRIZZLE_COLUMN_TYPE_FLOAT:
    case DRIZZLE_COLUMN_TYPE_DOUBLE:
    case DRIZZLE_COLUMN_TYPE_DECIMAL:
    case DRIZZLE_COLUMN_TYPE_NEWDECIMAL:
        this-&gt;type = NUMBER;
        break;
    case DRIZZLE_COLUMN_TYPE_DATE:
    case DRIZZLE_COLUMN_TYPE_NEWDATE:
        this-&gt;type = DATE;
        break;
    case DRIZZLE_COLUMN_TYPE_TIME:
        this-&gt;type = TIME;
        break;
    case DRIZZLE_COLUMN_TYPE_TIMESTAMP:
    case DRIZZLE_COLUMN_TYPE_DATETIME:
        this-&gt;type = DATETIME;
        break;
    case DRIZZLE_COLUMN_TYPE_TINY_BLOB:
    case DRIZZLE_COLUMN_TYPE_MEDIUM_BLOB:
    case DRIZZLE_COLUMN_TYPE_LONG_BLOB:
    case DRIZZLE_COLUMN_TYPE_BLOB:
        this-&gt;type = TEXT;
        break;
    case DRIZZLE_COLUMN_TYPE_SET:
        this-&gt;type = SET;
        break;
    default:
        this-&gt;type = STRING;
        break;
}</code></pre>

<p>}</p>

<p>drizzle::Result::Column::~Column() {
}</p>

<p>std::string drizzle::Result::Column::getName() const {
    return this-&gt;name;
}</p>

<p>drizzle::Result::Column::type_t drizzle::Result::Column::getType() const {
    return this-&gt;type;
}</p>

<p>drizzle::Result::Result(drizzle<em>st* drizzle, drizzle</em>result_st* result) throw(drizzle::Exception&amp;)
    : columns(NULL),
    totalColumns(0),
    rowNumber(0),
    drizzle(drizzle),
    result(result),
    previousRow(NULL),
    nextRow(NULL) {
    if (this-&gt;result == NULL) {
        throw drizzle::Exception("Invalid result");
    }</p>

<pre><code>if (drizzle_column_buffer(this-&gt;result) != DRIZZLE_RETURN_OK) {
    drizzle_result_free(this-&gt;result);
    throw drizzle::Exception("Could not buffer columns");
}

this-&gt;totalColumns = drizzle_result_column_count(this-&gt;result);
if (this-&gt;totalColumns &gt; 0) {
    this-&gt;columns = new Column*[this-&gt;totalColumns];
    if (this-&gt;columns == NULL) {
        drizzle_result_free(this-&gt;result);
        throw drizzle::Exception("Could not allocate storage for columns");
    }

    uint16_t i = 0;
    drizzle_column_st *current;
    while ((current = drizzle_column_next(this-&gt;result)) != NULL) {
        this-&gt;columns[i++] = new Column(current);
    }
}

this-&gt;nextRow = this-&gt;row();</code></pre>

<p>}</p>

<p>drizzle::Result::~Result() {
    if (this-&gt;columns != NULL) {
        for (uint16<em>t i = 0; i &lt; this-&gt;totalColumns; i++) {
            delete this-&gt;columns[i];
        }
        delete [] this-&gt;columns;
    }
    if (this-&gt;result != NULL) {
        if (this-&gt;previousRow != NULL) {
            drizzle</em>row<em>free(this-&gt;result, this-&gt;previousRow);
        }
        if (this-&gt;nextRow != NULL) {
            drizzle</em>row<em>free(this-&gt;result, this-&gt;nextRow);
        }
        drizzle</em>result_free(this-&gt;result);
    }
}</p>

<p>bool drizzle::Result::hasNext() const {
    return (this-&gt;nextRow != NULL);
}</p>

<p>const char** drizzle::Result::next() throw(drizzle::Exception&amp;) {
    if (this-&gt;previousRow != NULL) {
        drizzle<em>row</em>free(this-&gt;result, this-&gt;previousRow);
    }</p>

<pre><code>if (this-&gt;nextRow == NULL) {
    return NULL;
}

this-&gt;rowNumber++;
this-&gt;previousRow = this-&gt;nextRow;
this-&gt;nextRow = this-&gt;row();

return (const char**) this-&gt;previousRow;</code></pre>

<p>}</p>

<p>char<strong> drizzle::Result::row() throw(drizzle::Exception&amp;) {
    drizzle<em>return</em>t result = DRIZZLE<em>RETURN</em>IO_WAIT;
    char </strong>row = NULL;</p>

<pre><code>while (result == DRIZZLE_RETURN_IO_WAIT) {
    row = drizzle_row_buffer(this-&gt;result, &amp;result);
    if (result == DRIZZLE_RETURN_IO_WAIT) {
        if (drizzle_con_wait(this-&gt;drizzle) != DRIZZLE_RETURN_OK) {
            throw drizzle::Exception("Could not wait for connection");
        }

        if (drizzle_con_ready(this-&gt;drizzle) == NULL) {
            throw drizzle::Exception("Could not fetch connection");
        }
    }
}

if (result != DRIZZLE_RETURN_OK) {
    if (row != NULL) {
        drizzle_row_free(this-&gt;result, row);
        row = NULL;
    }
    throw drizzle::Exception("Could not prefetch next row");
}

return row;</code></pre>

<p>}</p>

<p>uint64<em>t drizzle::Result::index() const throw(std::out</em>of<em>range&amp;) {
    if (this-&gt;rowNumber == 0) {
        throw std::out</em>of_range("Not standing on a row");
    }
    return (this-&gt;rowNumber - 1);
}</p>

<p>drizzle::Result::Column* drizzle::Result::column(uint16<em>t i) const throw(std::out</em>of<em>range&amp;) {
    if (i &lt; 0 || i &gt;= this-&gt;totalColumns) {
        throw std::out</em>of_range("Wrong column index");
    }
    return this-&gt;columns[i];
}</p>

<p>uint64<em>t drizzle::Result::insertId() const {
    return drizzle</em>result<em>insert</em>id(this-&gt;result);
}</p>

<p>uint64<em>t drizzle::Result::affectedCount() const {
    return drizzle</em>result<em>affected</em>rows(this-&gt;result);
}</p>

<p>uint16<em>t drizzle::Result::warningCount() const {
    return drizzle</em>result<em>warning</em>count(this-&gt;result);
}</p>

<p>uint16_t drizzle::Result::columnCount() const {
    return this-&gt;totalColumns;
}</p>
</td>
<td class="code">

</td>
</tr><tr class="filename"><td><h2 id="./src/drizzle.cc"><a href="#">drizzle.cc</a></h2></td><td>./src/drizzle.cc</td></tr><tr class="code">
<td class="docs">
<p>// Copyright 2011 Mariano Iglesias <a href="mailto:mgiglesias@gmail.com">mgiglesias@gmail.com</a>
#include "./drizzle.h"</p>

<p>void node_drizzle::Drizzle::Init(v8::Handle&lt;v8::Object&gt; target) {
    v8::HandleScope scope;</p>

<pre><code>v8::Local&lt;v8::FunctionTemplate&gt; functionTemplate = v8::FunctionTemplate::New(New);
functionTemplate-&gt;Inherit(node::EventEmitter::constructor_template);

v8::Local&lt;v8::ObjectTemplate&gt; instanceTemplate = functionTemplate-&gt;InstanceTemplate();
instanceTemplate-&gt;SetInternalFieldCount(1);

NODE_DEFINE_CONSTANT(instanceTemplate, COLUMN_TYPE_STRING);
NODE_DEFINE_CONSTANT(instanceTemplate, COLUMN_TYPE_BOOL);
NODE_DEFINE_CONSTANT(instanceTemplate, COLUMN_TYPE_INT);
NODE_DEFINE_CONSTANT(instanceTemplate, COLUMN_TYPE_NUMBER);
NODE_DEFINE_CONSTANT(instanceTemplate, COLUMN_TYPE_DATE);
NODE_DEFINE_CONSTANT(instanceTemplate, COLUMN_TYPE_TIME);
NODE_DEFINE_CONSTANT(instanceTemplate, COLUMN_TYPE_DATETIME);
NODE_DEFINE_CONSTANT(instanceTemplate, COLUMN_TYPE_TEXT);
NODE_DEFINE_CONSTANT(instanceTemplate, COLUMN_TYPE_SET);

NODE_ADD_PROTOTYPE_METHOD(functionTemplate, "connect", Connect);
NODE_ADD_PROTOTYPE_METHOD(functionTemplate, "disconnect", Disconnect);
NODE_ADD_PROTOTYPE_METHOD(functionTemplate, "escape", Escape);
NODE_ADD_PROTOTYPE_METHOD(functionTemplate, "query", Query);

target-&gt;Set(v8::String::NewSymbol("Drizzle"), functionTemplate-&gt;GetFunction());</code></pre>

<p>}</p>

<p>node_drizzle::Drizzle::Drizzle(): node::EventEmitter(),
    connection(NULL) {
}</p>

<p>node_drizzle::Drizzle::~Drizzle() {
    if (this-&gt;connection != NULL) {
        delete this-&gt;connection;
    }
}</p>

<p>v8::Handle&lt;v8::Value&gt; node_drizzle::Drizzle::New(const v8::Arguments&amp; args) {
    v8::HandleScope scope;</p>

<pre><code>node_drizzle::Drizzle *drizzle = new node_drizzle::Drizzle();
drizzle-&gt;Wrap(args.This());

return args.This();</code></pre>

<p>}</p>

<p>v8::Handle&lt;v8::Value&gt; node_drizzle::Drizzle::Connect(const v8::Arguments&amp; args) {
    v8::HandleScope scope;</p>

<pre><code>ARG_CHECK_OBJECT(0, options);

v8::Local&lt;v8::Object&gt; options = args[0]-&gt;ToObject();

ARG_CHECK_OBJECT_ATTR_STRING(options, hostname);
ARG_CHECK_OBJECT_ATTR_STRING(options, user);
ARG_CHECK_OBJECT_ATTR_STRING(options, password);
ARG_CHECK_OBJECT_ATTR_STRING(options, database);
ARG_CHECK_OBJECT_ATTR_OPTIONAL_UINT32(options, port);
ARG_CHECK_OBJECT_ATTR_OPTIONAL_BOOL(options, mysql);
ARG_CHECK_OBJECT_ATTR_OPTIONAL_FUNCTION(options, success);
ARG_CHECK_OBJECT_ATTR_OPTIONAL_FUNCTION(options, error);
ARG_CHECK_OBJECT_ATTR_OPTIONAL_BOOL(options, async);

node_drizzle::Drizzle *drizzle = node::ObjectWrap::Unwrap&lt;node_drizzle::Drizzle&gt;(args.This());
assert(drizzle);

if (drizzle-&gt;connection != NULL) {
    delete drizzle-&gt;connection;
}

v8::String::Utf8Value hostname(options-&gt;Get(hostname_key)-&gt;ToString());
v8::String::Utf8Value user(options-&gt;Get(user_key)-&gt;ToString());
v8::String::Utf8Value password(options-&gt;Get(password_key)-&gt;ToString());
v8::String::Utf8Value database(options-&gt;Get(database_key)-&gt;ToString());

drizzle-&gt;connection = new drizzle::Connection();
drizzle-&gt;connection-&gt;setHostname(*hostname);
drizzle-&gt;connection-&gt;setUser(*user);
drizzle-&gt;connection-&gt;setPassword(*password);
drizzle-&gt;connection-&gt;setDatabase(*database);

if (options-&gt;Has(port_key)) {
    drizzle-&gt;connection-&gt;setPort(options-&gt;Get(mysql_key)-&gt;ToInt32()-&gt;Value());
}

if (options-&gt;Has(mysql_key)) {
    drizzle-&gt;connection-&gt;setMysql(options-&gt;Get(mysql_key)-&gt;IsTrue());
}

connect_request_t *request = new connect_request_t();
request-&gt;drizzle = drizzle;
request-&gt;error = NULL;

if (options-&gt;Has(success_key)) {
    request-&gt;cbSuccess = v8::Persistent&lt;v8::Function&gt;::New(v8::Local&lt;v8::Function&gt;::Cast(options-&gt;Get(success_key)));
}

if (options-&gt;Has(error_key)) {
    request-&gt;cbError = v8::Persistent&lt;v8::Function&gt;::New(v8::Local&lt;v8::Function&gt;::Cast(options-&gt;Get(error_key)));
}

bool async = options-&gt;Has(async_key) ? options-&gt;Get(async_key)-&gt;IsTrue() : true;
if (async) {
    request-&gt;drizzle-&gt;Ref();
    eio_custom(eioConnect, EIO_PRI_DEFAULT, eioConnectFinished, request);
    ev_ref(EV_DEFAULT_UC);
} else {
    connect(request);
    connectFinished(request);
}

return v8::Undefined();</code></pre>

<p>}</p>

<p>void node<em>drizzle::Drizzle::connect(connect</em>request_t* request) {
    try {
        request-&gt;drizzle-&gt;connection-&gt;open();
    } catch(const drizzle::Exception&amp; exception) {
        request-&gt;error = exception.what();
    }
}</p>

<p>void node<em>drizzle::Drizzle::connectFinished(connect</em>request_t* request) {
    bool connected = request-&gt;drizzle-&gt;connection-&gt;isOpened();</p>

<pre><code>v8::TryCatch tryCatch;

if (connected &amp;&amp; !request-&gt;cbSuccess.IsEmpty()) {
    v8::Local&lt;v8::Object&gt; server = v8::Object::New();
    server-&gt;Set(v8::String::New("version"), v8::String::New(request-&gt;drizzle-&gt;connection-&gt;version().c_str()));
    server-&gt;Set(v8::String::New("hostname"), v8::String::New(request-&gt;drizzle-&gt;connection-&gt;getHostname().c_str()));
    server-&gt;Set(v8::String::New("user"), v8::String::New(request-&gt;drizzle-&gt;connection-&gt;getUser().c_str()));
    server-&gt;Set(v8::String::New("database"), v8::String::New(request-&gt;drizzle-&gt;connection-&gt;getDatabase().c_str()));

    v8::Local&lt;v8::Value&gt; argv[1];
    argv[0] = server;

    request-&gt;cbSuccess-&gt;Call(v8::Context::GetCurrent()-&gt;Global(), 1, argv);
} else if (!connected &amp;&amp; !request-&gt;cbError.IsEmpty()) {
    v8::Local&lt;v8::Value&gt; argv[1];
    argv[0] = v8::String::New(request-&gt;error != NULL ? request-&gt;error : "(unknown error)");
    request-&gt;cbError-&gt;Call(v8::Context::GetCurrent()-&gt;Global(), 1, argv);
}

if (tryCatch.HasCaught()) {
    node::FatalException(tryCatch);
}

request-&gt;cbSuccess.Dispose();
request-&gt;cbError.Dispose();

delete request;</code></pre>

<p>}</p>

<p>int node<em>drizzle::Drizzle::eioConnect(eio</em>req* eioRequest) {
    connect<em>request</em>t *request = static<em>cast&lt;connect</em>request_t *&gt;(eioRequest-&gt;data);
    assert(request);</p>

<pre><code>connect(request);

return 0;</code></pre>

<p>}</p>

<p>int node<em>drizzle::Drizzle::eioConnectFinished(eio</em>req* eioRequest) {
    v8::HandleScope scope;</p>

<pre><code>connect_request_t *request = static_cast&lt;connect_request_t *&gt;(eioRequest-&gt;data);
assert(request);

ev_unref(EV_DEFAULT_UC);
request-&gt;drizzle-&gt;Unref();

connectFinished(request);

return 0;</code></pre>

<p>}</p>

<p>v8::Handle&lt;v8::Value&gt; node_drizzle::Drizzle::Disconnect(const v8::Arguments&amp; args) {
    v8::HandleScope scope;</p>

<pre><code>node_drizzle::Drizzle *drizzle = node::ObjectWrap::Unwrap&lt;node_drizzle::Drizzle&gt;(args.This());
assert(drizzle);

if (drizzle-&gt;connection != NULL) {
    drizzle-&gt;connection-&gt;close();
    delete drizzle-&gt;connection;
}

return v8::Undefined();</code></pre>

<p>}</p>

<p>v8::Handle&lt;v8::Value&gt; node_drizzle::Drizzle::Escape(const v8::Arguments&amp; args) {
    v8::HandleScope scope;</p>

<pre><code>ARG_CHECK_STRING(0, string);

node_drizzle::Drizzle *drizzle = node::ObjectWrap::Unwrap&lt;node_drizzle::Drizzle&gt;(args.This());
assert(drizzle);

std::string escaped;

try {
    v8::String::Utf8Value string(args[0]-&gt;ToString());
    std::string unescaped(*string);
    escaped = drizzle-&gt;connection-&gt;escape(unescaped);
} catch(const drizzle::Exception&amp; exception) {
    return v8::ThrowException(v8::Exception::Error(v8::String::New(exception.what())));
}

return v8::String::New(escaped.c_str());</code></pre>

<p>}</p>

<p>v8::Handle&lt;v8::Value&gt; node_drizzle::Drizzle::Query(const v8::Arguments&amp; args) {
    v8::HandleScope scope;</p>

<pre><code>ARG_CHECK_STRING(0, query);

if (args.Length() &gt; 2) {
    ARG_CHECK_ARRAY(1, values);
    ARG_CHECK_OBJECT(2, options);
} else {
    ARG_CHECK_OBJECT(1, options);
}

v8::Local&lt;v8::Object&gt; options = args[args.Length() &gt; 2 ? 2 : 1]-&gt;ToObject();

ARG_CHECK_OBJECT_ATTR_OPTIONAL_BOOL(options, buffer);
ARG_CHECK_OBJECT_ATTR_OPTIONAL_BOOL(options, cast);
ARG_CHECK_OBJECT_ATTR_OPTIONAL_FUNCTION(options, start);
ARG_CHECK_OBJECT_ATTR_OPTIONAL_FUNCTION(options, finish);
ARG_CHECK_OBJECT_ATTR_OPTIONAL_FUNCTION(options, success);
ARG_CHECK_OBJECT_ATTR_OPTIONAL_FUNCTION(options, error);
ARG_CHECK_OBJECT_ATTR_OPTIONAL_FUNCTION(options, each);

v8::String::Utf8Value query(args[0]-&gt;ToString());

node_drizzle::Drizzle *drizzle = node::ObjectWrap::Unwrap&lt;node_drizzle::Drizzle&gt;(args.This());
assert(drizzle);

query_request_t *request = new query_request_t();
request-&gt;drizzle = drizzle;
request-&gt;cast = true;
request-&gt;buffer = true;
request-&gt;query = *query;
request-&gt;result = NULL;
request-&gt;rows = NULL;
request-&gt;error = NULL;

if (options-&gt;Has(buffer_key)) {
    request-&gt;buffer = options-&gt;Get(buffer_key)-&gt;IsTrue();
}

if (options-&gt;Has(cast_key)) {
    request-&gt;cast = options-&gt;Get(cast_key)-&gt;IsTrue();
}

if (options-&gt;Has(start_key)) {
    request-&gt;cbStart = v8::Persistent&lt;v8::Function&gt;::New(v8::Local&lt;v8::Function&gt;::Cast(options-&gt;Get(start_key)));
}

if (options-&gt;Has(finish_key)) {
    request-&gt;cbFinish = v8::Persistent&lt;v8::Function&gt;::New(v8::Local&lt;v8::Function&gt;::Cast(options-&gt;Get(finish_key)));
}

if (options-&gt;Has(success_key)) {
    request-&gt;cbSuccess = v8::Persistent&lt;v8::Function&gt;::New(v8::Local&lt;v8::Function&gt;::Cast(options-&gt;Get(success_key)));
}

if (options-&gt;Has(error_key)) {
    request-&gt;cbError = v8::Persistent&lt;v8::Function&gt;::New(v8::Local&lt;v8::Function&gt;::Cast(options-&gt;Get(error_key)));
}

if (options-&gt;Has(each_key)) {
    request-&gt;cbEach = v8::Persistent&lt;v8::Function&gt;::New(v8::Local&lt;v8::Function&gt;::Cast(options-&gt;Get(each_key)));
}

v8::Local&lt;v8::Array&gt; values;

if (args.Length() &gt; 2) {
    values = v8::Array::Cast(*args[1]);
} else {
    values = v8::Array::New();
}

try {
    request-&gt;query = drizzle-&gt;parseQuery(request-&gt;query, values);
} catch(const drizzle::Exception&amp; exception) {
    return v8::ThrowException(v8::Exception::Error(v8::String::New(exception.what())));
}

if (!request-&gt;cbStart.IsEmpty()) {
    v8::Local&lt;v8::Value&gt; argv[1];
    argv[0] = v8::String::New(request-&gt;query.c_str());

    v8::TryCatch tryCatch;
    v8::Handle&lt;v8::Value&gt; result = request-&gt;cbStart-&gt;Call(v8::Context::GetCurrent()-&gt;Global(), 1, argv);
    if (tryCatch.HasCaught()) {
        node::FatalException(tryCatch);
    }

    if (!result-&gt;IsUndefined()) {
        if (result-&gt;IsFalse()) {
            eioQueryRequestFree(request);
            return v8::Undefined();
        } else if (result-&gt;IsString()) {
            v8::String::Utf8Value modifiedQuery(result-&gt;ToString());
            request-&gt;query = *modifiedQuery;
        }
    }
}

request-&gt;drizzle-&gt;Ref();
eio_custom(eioQuery, EIO_PRI_DEFAULT, eioQueryFinished, request);
ev_ref(EV_DEFAULT_UC);

return v8::Undefined();</code></pre>

<p>}</p>

<p>int node<em>drizzle::Drizzle::eioQuery(eio</em>req* eioRequest) {
    query<em>request</em>t *request = static<em>cast&lt;query</em>request_t *&gt;(eioRequest-&gt;data);
    assert(request);</p>

<pre><code>try {
    request-&gt;result = request-&gt;drizzle-&gt;connection-&gt;query(request-&gt;query);

    if (request-&gt;buffer) {
        request-&gt;rows = new std::vector&lt;std::string**&gt;();
        if (request-&gt;rows == NULL) {
            throw drizzle::Exception("Could not create buffer for rows");
        }

        uint16_t columnCount = request-&gt;result-&gt;columnCount();
        while (request-&gt;result-&gt;hasNext()) {
            const char **currentRow = request-&gt;result-&gt;next();
            std::string** row = new std::string*[columnCount];
            if (row == NULL) {
                throw drizzle::Exception("Could not create buffer for row");
            }

            for (uint16_t i = 0; i &lt; columnCount; i++) {
                if (currentRow[i] != NULL) {
                    row[i] = new std::string(currentRow[i]);
                } else {
                    row[i] = NULL;
                }
            }

            request-&gt;rows-&gt;push_back(row);
        }
    }
} catch(const drizzle::Exception&amp; exception) {
    if (request-&gt;rows != NULL) {
        delete request-&gt;rows;
    }
    request-&gt;error = exception.what();
}

return 0;</code></pre>

<p>}</p>

<p>int node<em>drizzle::Drizzle::eioQueryFinished(eio</em>req* eioRequest) {
    v8::HandleScope scope;</p>

<pre><code>query_request_t *request = static_cast&lt;query_request_t *&gt;(eioRequest-&gt;data);
assert(request);

uint16_t columnCount = (request-&gt;result != NULL ? request-&gt;result-&gt;columnCount() : 0);
if (request-&gt;error == NULL) {
    assert(request-&gt;result);

    v8::Local&lt;v8::Value&gt; argv[2];
    uint8_t argc = 1;

    v8::Local&lt;v8::Array&gt; columns = v8::Array::New(columnCount);
    for (uint16_t j = 0; j &lt; columnCount; j++) {
        drizzle::Result::Column *currentColumn = request-&gt;result-&gt;column(j);
        v8::Local&lt;v8::Value&gt; columnType;

        switch (currentColumn-&gt;getType()) {
            case drizzle::Result::Column::BOOL:
                columnType = NODE_CONSTANT(COLUMN_TYPE_BOOL);
                break;
            case drizzle::Result::Column::INT:
                columnType = NODE_CONSTANT(COLUMN_TYPE_INT);
                break;
            case drizzle::Result::Column::NUMBER:
                columnType = NODE_CONSTANT(COLUMN_TYPE_NUMBER);
                break;
            case drizzle::Result::Column::DATE:
                columnType = NODE_CONSTANT(COLUMN_TYPE_DATE);
                break;
            case drizzle::Result::Column::TIME:
                columnType = NODE_CONSTANT(COLUMN_TYPE_TIME);
                break;
            case drizzle::Result::Column::DATETIME:
                columnType = NODE_CONSTANT(COLUMN_TYPE_DATETIME);
                break;
            case drizzle::Result::Column::TEXT:
                columnType = NODE_CONSTANT(COLUMN_TYPE_TEXT);
                break;
            case drizzle::Result::Column::SET:
                columnType = NODE_CONSTANT(COLUMN_TYPE_SET);
                break;
            default:
                columnType = NODE_CONSTANT(COLUMN_TYPE_STRING);
                break;
        }

        v8::Local&lt;v8::Object&gt; column = v8::Object::New();
        column-&gt;Set(v8::String::New("name"), v8::String::New(currentColumn-&gt;getName().c_str()));
        column-&gt;Set(v8::String::New("type"), columnType);

        columns-&gt;Set(j, column);
    }

    argv[0] = columns;

    v8::Local&lt;v8::Array&gt; rows = v8::Array::New();

    if (request-&gt;buffer) {
        assert(request-&gt;rows);

        uint64_t index = 0;
        for (std::vector&lt;std::string**&gt;::iterator iterator = request-&gt;rows-&gt;begin(), end = request-&gt;rows-&gt;end(); iterator != end; ++iterator, index++) {
            std::string** row = *iterator;
            rows-&gt;Set(index, request-&gt;drizzle-&gt;row(request-&gt;result, row, request-&gt;cast));
        }

        argc = 2;
        argv[1] = rows;
    }

    if (!request-&gt;cbSuccess.IsEmpty()) {
        v8::TryCatch tryCatch;
        request-&gt;cbSuccess-&gt;Call(v8::Context::GetCurrent()-&gt;Global(), argc, argv);
        if (tryCatch.HasCaught()) {
            node::FatalException(tryCatch);
        }
    }

    if (request-&gt;buffer &amp;&amp; !request-&gt;cbEach.IsEmpty()) {
        uint64_t index = 0;
        for (std::vector&lt;std::string**&gt;::iterator iterator = request-&gt;rows-&gt;begin(), end = request-&gt;rows-&gt;end(); iterator != end; ++iterator, index++) {
            v8::Local&lt;v8::Value&gt; eachArgv[3];

            eachArgv[0] = rows-&gt;Get(index);
            eachArgv[1] = v8::Number::New(index);
            eachArgv[2] = v8::Local&lt;v8::Value&gt;::New(iterator == end ? v8::True() : v8::False());

            v8::TryCatch tryCatch;
            request-&gt;cbEach-&gt;Call(v8::Context::GetCurrent()-&gt;Global(), 3, eachArgv);
            if (tryCatch.HasCaught()) {
                node::FatalException(tryCatch);
            }
        }
    }
} else if (!request-&gt;cbError.IsEmpty()) {
    v8::Local&lt;v8::Value&gt; argv[1];
    argv[0] = v8::String::New(request-&gt;error != NULL ? request-&gt;error : "(unknown error)");

    v8::TryCatch tryCatch;
    request-&gt;cbError-&gt;Call(v8::Context::GetCurrent()-&gt;Global(), 1, argv);
    if (tryCatch.HasCaught()) {
        node::FatalException(tryCatch);
    }
}

eioQueryCleanup(request);

return 0;</code></pre>

<p>}</p>

<p>int node<em>drizzle::Drizzle::eioQueryEach(eio</em>req* eioRequest) {
    query<em>request</em>t *request = static<em>cast&lt;query</em>request_t *&gt;(eioRequest-&gt;data);
    assert(request);</p>

<pre><code>try {
    if (request-&gt;result-&gt;hasNext()) {
        const char **currentRow = request-&gt;result-&gt;next();
        request-&gt;rows = new std::vector&lt;std::string**&gt;();
        if (request-&gt;rows == NULL) {
            throw drizzle::Exception("Could not create buffer for rows");
        }

        uint16_t columnCount = request-&gt;result-&gt;columnCount();
        std::string** row = new std::string*[columnCount];
        if (row == NULL) {
            throw drizzle::Exception("Could not create buffer for row");
        }

        for (uint16_t i = 0; i &lt; columnCount; i++) {
            if (currentRow[i] != NULL) {
                row[i] = new std::string(currentRow[i]);
            } else {
                row[i] = NULL;
            }
        }

        request-&gt;rows-&gt;push_back(row);
    }
} catch(const drizzle::Exception&amp; exception) {
    if (request-&gt;rows != NULL) {
        delete request-&gt;rows;
    }
    request-&gt;error = exception.what();
}

return 0;</code></pre>

<p>}</p>

<p>int node<em>drizzle::Drizzle::eioQueryEachFinished(eio</em>req* eioRequest) {
    v8::HandleScope scope;</p>

<pre><code>query_request_t *request = static_cast&lt;query_request_t *&gt;(eioRequest-&gt;data);
assert(request);

if (!request-&gt;cbEach.IsEmpty() &amp;&amp; request-&gt;rows != NULL) {
    v8::Local&lt;v8::Value&gt; eachArgv[3];

    eachArgv[0] = request-&gt;drizzle-&gt;row(request-&gt;result, request-&gt;rows-&gt;front(), request-&gt;cast);
    eachArgv[1] = v8::Number::New(request-&gt;result-&gt;index());
    eachArgv[2] = v8::Local&lt;v8::Value&gt;::New(request-&gt;result-&gt;hasNext() ? v8::False() : v8::True());

    v8::TryCatch tryCatch;
    request-&gt;cbEach-&gt;Call(v8::Context::GetCurrent()-&gt;Global(), 3, eachArgv);
    if (tryCatch.HasCaught()) {
        node::FatalException(tryCatch);
    }
}

eioQueryCleanup(request);

return 0;</code></pre>

<p>}</p>

<p>void node<em>drizzle::Drizzle::eioQueryCleanup(query</em>request<em>t* request) {
    ev</em>unref(EV<em>DEFAULT</em>UC);
    request-&gt;drizzle-&gt;Unref();</p>

<pre><code>if (request-&gt;result == NULL || !request-&gt;result-&gt;hasNext()) {
    if (!request-&gt;cbFinish.IsEmpty()) {
        v8::TryCatch tryCatch;
        request-&gt;cbFinish-&gt;Call(v8::Context::GetCurrent()-&gt;Global(), 0, NULL);
        if (tryCatch.HasCaught()) {
            node::FatalException(tryCatch);
        }
    }

    eioQueryRequestFree(request);
} else {
    request-&gt;drizzle-&gt;Ref();
    eio_custom(eioQueryEach, EIO_PRI_DEFAULT, eioQueryEachFinished, request);
    ev_ref(EV_DEFAULT_UC);
}</code></pre>

<p>}</p>

<p>void node<em>drizzle::Drizzle::eioQueryRequestFree(query</em>request<em>t* request) {
    if (request-&gt;result != NULL) {
        if (request-&gt;rows != NULL) {
            uint16</em>t columnCount = request-&gt;result-&gt;columnCount();
            for (std::vector&lt;std::string<strong>&gt;::iterator iterator = request-&gt;rows-&gt;begin(), end = request-&gt;rows-&gt;end(); iterator != end; ++iterator) {
                std::string</strong> row = *iterator;
                for (uint16_t i = 0; i &lt; columnCount; i++) {
                    if (row[i] != NULL) {
                        delete row[i];
                    }
                }
                delete [] row;
            }</p>

<pre><code>        delete request-&gt;rows;
    }

    delete request-&gt;result;
}

request-&gt;cbStart.Dispose();
request-&gt;cbFinish.Dispose();
request-&gt;cbSuccess.Dispose();
request-&gt;cbError.Dispose();
request-&gt;cbEach.Dispose();

delete request;</code></pre>

<p>}</p>

<p>v8::Local&lt;v8::Object&gt; node_drizzle::Drizzle::row(drizzle::Result* result, std::string** currentRow, bool cast) const {
    v8::Local&lt;v8::Object&gt; row = v8::Object::New();</p>

<pre><code>for (uint16_t j = 0, limitj = result-&gt;columnCount(); j &lt; limitj; j++) {
    drizzle::Result::Column* currentColumn = result-&gt;column(j);
    v8::Local&lt;v8::Value&gt; value;

    if (currentRow[j] != NULL) {
        const char* currentValue = currentRow[j]-&gt;c_str();
        if (cast) {
            switch (currentColumn-&gt;getType()) {
                case drizzle::Result::Column::BOOL:
                    value = v8::Local&lt;v8::Value&gt;::New(currentRow[j]-&gt;empty() || currentRow[j]-&gt;compare("0") != 0 ? v8::True() : v8::False());
                    break;
                case drizzle::Result::Column::INT:
                    value = v8::String::New(currentValue)-&gt;ToInteger();
                    break;
                case drizzle::Result::Column::NUMBER:
                    value = v8::Number::New(::atof(currentValue));
                    break;
                case drizzle::Result::Column::DATE:
                    try {
                        value = v8::Date::New(this-&gt;toDate(*currentRow[j], false));
                    } catch(const drizzle::Exception&amp;) {
                        value = v8::String::New(currentValue);
                    }
                    break;
                case drizzle::Result::Column::TIME:
                    value = v8::Date::New(this-&gt;toTime(*currentRow[j]));
                    break;
                case drizzle::Result::Column::DATETIME:
                    try {
                        value = v8::Date::New(this-&gt;toDate(*currentRow[j], true));
                    } catch(const drizzle::Exception&amp;) {
                        value = v8::String::New(currentValue);
                    }
                    break;
                case drizzle::Result::Column::TEXT:
                    value = v8::Local&lt;v8::Value&gt;::New(node::Buffer::New(v8::String::New(currentValue, currentRow[j]-&gt;length())));
                    break;
                case drizzle::Result::Column::SET:
                    {
                        v8::Local&lt;v8::Array&gt; values = v8::Array::New();
                        std::istringstream stream(*currentRow[j]);
                        std::string item;
                        uint64_t index = 0;
                        while (std::getline(stream, item, ',')) {
                            if (!item.empty()) {
                                values-&gt;Set(v8::Integer::New(index++), v8::String::New(item.c_str()));
                            }
                        }
                        value = values;
                    }
                    break;
                default:
                    value = v8::String::New(currentValue);
                    break;
            }
        } else {
            value = v8::String::New(currentValue);
        }
    } else {
        value = v8::Local&lt;v8::Value&gt;::New(v8::Null());
    }
    row-&gt;Set(v8::String::New(currentColumn-&gt;getName().c_str()), value);
}

return row;</code></pre>

<p>}</p>

<p>std::string node<em>drizzle::Drizzle::parseQuery(const std::string&amp; query, v8::Local&lt;v8::Array&gt; values) const throw(drizzle::Exception&amp;) {
    std::string parsed(query);
    std::vector&lt;std::string::size</em>type&gt; positions;
    char quote = 0;
    bool escaped = false;
    uint32_t delta = 0;</p>

<pre><code>for (std::string::size_type i = 0, limiti = query.length(); i &lt; limiti; i++) {
    char currentChar = query[i];
    if (escaped) {
        if (currentChar == '?') {
            parsed.replace(i - 1 - delta, 1, "");
            delta++;
        }
        escaped = false;
    } else if (currentChar == '\\') {
        escaped = true;
    } else if (quote &amp;&amp; currentChar == quote) {
        quote = 0;
    } else if (!quote &amp;&amp; (currentChar == '\'' || currentChar == '"')) {
        quote = currentChar;
    } else if (!quote &amp;&amp; currentChar == '?') {
        positions.push_back(i - delta);
    }
}

if (positions.size() != values-&gt;Length()) {
    throw drizzle::Exception("Wrong number of values to escape");
}

uint32_t index = 0;
delta = 0;
for (std::vector&lt;std::string::size_type&gt;::iterator iterator = positions.begin(), end = positions.end(); iterator != end; ++iterator, index++) {
    std::string value = this-&gt;value(values-&gt;Get(index));
    parsed.replace(*iterator + delta, 1, value);
    delta += (value.length() - 1);
}

return parsed;</code></pre>

<p>}</p>

<p>std::string node_drizzle::Drizzle::value(v8::Local&lt;v8::Value&gt; value, bool inArray) const throw(drizzle::Exception&amp;) {
    std::ostringstream currentStream;</p>

<pre><code>if (value-&gt;IsArray()) {
    v8::Local&lt;v8::Array&gt; array = v8::Array::Cast(*value);
    if (!inArray) {
        currentStream &lt;&lt; "(";
    }
    for (uint32_t i = 0, limiti = array-&gt;Length(); i &lt; limiti; i++) {
        v8::Local&lt;v8::Value&gt; child = array-&gt;Get(i);
        if (child-&gt;IsArray() &amp;&amp; i &gt; 0) {
            currentStream &lt;&lt; "),(";
        } else if (i &gt; 0) {
            currentStream &lt;&lt; ",";
        }

        currentStream &lt;&lt; this-&gt;value(child, true);
    }
    if (!inArray) {
        currentStream &lt;&lt; ")";
    }
} else if (value-&gt;IsDate()) {
    currentStream &lt;&lt; '\'' &lt;&lt;  this-&gt;fromDate(v8::Date::Cast(*value)-&gt;NumberValue()) &lt;&lt; '\'';
} else if (value-&gt;IsBoolean()) {
    currentStream &lt;&lt; (value-&gt;IsTrue() ? "1" : "0");
} else if (value-&gt;IsNumber()) {
    currentStream &lt;&lt; value-&gt;ToNumber()-&gt;Value();
} else if (value-&gt;IsString()) {
    v8::String::Utf8Value currentString(value-&gt;ToString());
    std::string string = *currentString;
    currentStream &lt;&lt; '\'' &lt;&lt;  this-&gt;connection-&gt;escape(string) &lt;&lt; '\'';
}

return currentStream.str();</code></pre>

<p>}</p>

<p>uint64<em>t node</em>drizzle::Drizzle::toDate(const std::string&amp; value, bool hasTime) const throw(drizzle::Exception&amp;) {
    int day, month, year, hour, min, sec;
    char sep;
    std::istringstream stream(value, std::istringstream::in);</p>

<pre><code>if (hasTime) {
    stream &gt;&gt; year &gt;&gt; sep &gt;&gt; month &gt;&gt; sep &gt;&gt; day &gt;&gt; hour &gt;&gt; sep &gt;&gt; min &gt;&gt; sep &gt;&gt; sec;
} else {
    stream &gt;&gt; year &gt;&gt; sep &gt;&gt; month &gt;&gt; sep &gt;&gt; day;
    hour = min = sec = 0;
}

time_t rawtime;
struct tm timeinfo;

time(&amp;rawtime);
if (!localtime_r(&amp;rawtime, &amp;timeinfo)) {
    throw drizzle::Exception("Can't get local time");
}

timeinfo.tm_year = year - 1900;
timeinfo.tm_mon = month - 1;
timeinfo.tm_mday = day;
timeinfo.tm_hour = hour;
timeinfo.tm_min = min;
timeinfo.tm_sec = sec;

return static_cast&lt;uint64_t&gt;((mktime(&amp;timeinfo) + this-&gt;gmtDelta()) * 1000);</code></pre>

<p>}</p>

<p>std::string node<em>drizzle::Drizzle::fromDate(const uint64</em>t timeStamp) const throw(drizzle::Exception&amp;) {
    char* buffer = new char[20];
    if (buffer == NULL) {
        throw drizzle::Exception("Can\'t create buffer to write parsed date");
    }</p>

<pre><code>struct tm timeinfo;
time_t rawtime = timeStamp / 1000;
if (!localtime_r(&amp;rawtime, &amp;timeinfo)) {
    throw drizzle::Exception("Can't get local time");
}

strftime(buffer, 20, "%Y-%m-%d %H:%M:%S", &amp;timeinfo);

std::string date(buffer);
delete [] buffer;

return date;</code></pre>

<p>}</p>

<p>int node<em>drizzle::Drizzle::gmtDelta() const throw(drizzle::Exception&amp;) {
    int localHour, gmtHour, localMin, gmtMin;
    time</em>t rawtime;
    struct tm timeinfo;</p>

<pre><code>time(&amp;rawtime);
if (!localtime_r(&amp;rawtime, &amp;timeinfo)) {
    throw drizzle::Exception("Can't get local time");
}
localHour = timeinfo.tm_hour - (timeinfo.tm_isdst &gt; 0 ? 1 : 0);
localMin = timeinfo.tm_min;

if (!gmtime_r(&amp;rawtime, &amp;timeinfo)) {
    throw drizzle::Exception("Can't get GMT time");
}
gmtHour = timeinfo.tm_hour;
gmtMin = timeinfo.tm_min;

int gmtDelta = ((localHour - gmtHour) * 60 + (localMin - gmtMin)) * 60;
if (gmtDelta &lt;= -(12 * 60 * 60)) {
    gmtDelta += 24 * 60 * 60;
} else if (gmtDelta &gt; (12 * 60 * 60)) {
    gmtDelta -= 24 * 60 * 60;
}

return gmtDelta;</code></pre>

<p>}</p>

<p>uint64<em>t node</em>drizzle::Drizzle::toTime(const std::string&amp; value) const {
    int hour, min, sec;
    char sep;
    std::istringstream stream(value, std::istringstream::in);</p>

<pre><code>stream &gt;&gt; hour &gt;&gt; sep &gt;&gt; min &gt;&gt; sep &gt;&gt; sec;

time_t rawtime;
struct tm timeinfo;

time(&amp;rawtime);
if (!localtime_r(&amp;rawtime, &amp;timeinfo)) {
    throw drizzle::Exception("Can't get local time");
}

timeinfo.tm_hour = hour;
timeinfo.tm_min = min;
timeinfo.tm_sec = sec;

return static_cast&lt;uint64_t&gt;((mktime(&amp;timeinfo) + this-&gt;gmtDelta()) * 1000);</code></pre>

<p>}</p>
</td>
<td class="code">

</td>
</tr><tr class="filename"><td><h2 id="./src/drizzle_bindings.h"><a href="#">drizzle_bindings.h</a></h2></td><td>./src/drizzle_bindings.h</td></tr><tr class="code">
<td class="docs">
<p>// Copyright 2011 Mariano Iglesias <a href="mailto:mgiglesias@gmail.com">mgiglesias@gmail.com</a>
#ifndef SRC<em>DRIZZLE</em>BINDINGS<em>H</em>
#define SRC<em>DRIZZLE</em>BINDINGS<em>H</em></p>

<h1>include &lt;node.h&gt;</h1>

<h1>define NODE_CONSTANT(constant) v8::Integer::New(constant)</h1>

<h1>define NODE_ADD_PROTOTYPE_METHOD(templ, name, callback)                  \</h1>

<p>do {                                                                      \
  v8::Local&lt;v8::Signature&gt; <strong>callback##_SIG = v8::Signature::New(templ);  \
  v8::Local&lt;v8::FunctionTemplate&gt; </strong>callback##<em>TEM =                      \
    v8::FunctionTemplate::New(callback, v8::Handle&lt;v8::Value&gt;(),          \
                          __callback##</em>SIG);                              \
  templ-&gt;PrototypeTemplate()-&gt;Set(v8::String::NewSymbol(name),            \
                                  __callback##_TEM);                      \
} while (0)</p>

<h1>define ARG_CHECK_OPTIONAL_STRING(I, VAR) \</h1>

<pre><code>if (args.Length() &gt; I &amp;&amp; !args[I]-&gt;IsString()) { \
    return v8::ThrowException(v8::Exception::Error(v8::String::New("Argument \"" #VAR "\" must be a valid string"))); \
}</code></pre>

<h1>define ARG_CHECK_STRING(I, VAR) \</h1>

<pre><code>if (args.Length() &lt;= I) { \
    return v8::ThrowException(v8::Exception::Error(v8::String::New("Argument \"" #VAR "\" is mandatory"))); \
} else if (!args[I]-&gt;IsString()) { \
    return v8::ThrowException(v8::Exception::Error(v8::String::New("Argument \"" #VAR "\" must be a valid string"))); \
}</code></pre>

<h1>define ARG_CHECK_OPTIONAL_OBJECT(I, VAR) \</h1>

<pre><code>if (args.Length() &gt; I &amp;&amp; (!args[I]-&gt;IsObject() || args[I]-&gt;IsFunction() || args[I]-&gt;IsUndefined())) { \
    return v8::ThrowException(v8::Exception::Error(v8::String::New("Argument \"" #VAR "\" must be a valid object"))); \
}</code></pre>

<h1>define ARG_CHECK_OBJECT(I, VAR) \</h1>

<pre><code>if (args.Length() &lt;= I) { \
    return v8::ThrowException(v8::Exception::Error(v8::String::New("Argument \"" #VAR "\" is mandatory"))); \
} else if (!args[I]-&gt;IsObject() || args[I]-&gt;IsFunction() || args[I]-&gt;IsUndefined()) { \
    return v8::ThrowException(v8::Exception::Error(v8::String::New("Argument \"" #VAR "\" must be a valid object"))); \
}</code></pre>

<h1>define ARG_CHECK_OPTIONAL_FUNCTION(I, VAR) \</h1>

<pre><code>if (args.Length() &gt; I &amp;&amp; !args[I]-&gt;IsFunction()) { \
    return v8::ThrowException(v8::Exception::Error(v8::String::New("Argument \"" #VAR "\" must be a valid function"))); \
}</code></pre>

<h1>define ARG_CHECK_FUNCTION(I, VAR) \</h1>

<pre><code>if (args.Length() &lt;= I) { \
    return v8::ThrowException(v8::Exception::Error(v8::String::New("Argument \"" #VAR "\" is mandatory"))); \
} else if (!args[I]-&gt;IsFunction()) { \
    return v8::ThrowException(v8::Exception::Error(v8::String::New("Argument \"" #VAR "\" must be a valid function"))); \
}</code></pre>

<h1>define ARG_CHECK_OPTIONAL_ARRAY(I, VAR) \</h1>

<pre><code>if (args.Length() &gt; I &amp;&amp; args[I]-&gt;IsArray()) { \
    return v8::ThrowException(v8::Exception::Error(v8::String::New("Argument \"" #VAR "\" must be a valid array"))); \
}</code></pre>

<h1>define ARG_CHECK_ARRAY(I, VAR) \</h1>

<pre><code>if (args.Length() &lt;= I) { \
    return v8::ThrowException(v8::Exception::Error(v8::String::New("Argument \"" #VAR "\" is mandatory"))); \
} else if (!args[I]-&gt;IsArray()) { \
    return v8::ThrowException(v8::Exception::Error(v8::String::New("Argument \"" #VAR "\" must be a valid array"))); \
}</code></pre>

<h1>define ARG_CHECK_OBJECT_ATTR_STRING(VAR, KEY) \</h1>

<pre><code>v8::Local&lt;v8::String&gt; KEY##_##key = v8::String::New("" #KEY ""); \
if (!VAR-&gt;Has(KEY##_##key)) { \
    return v8::ThrowException(v8::Exception::Error(v8::String::New("Option \"" #KEY "\" is mandatory"))); \
} else if (!VAR-&gt;Get(KEY##_##key)-&gt;IsString()) { \
    return v8::ThrowException(v8::Exception::Error(v8::String::New("Option \"" #KEY "\" must be a valid string"))); \
}</code></pre>

<h1>define ARG_CHECK_OBJECT_ATTR_OPTIONAL_STRING(VAR, KEY) \</h1>

<pre><code>v8::Local&lt;v8::String&gt; KEY##_##key = v8::String::New("" #KEY ""); \
if (VAR-&gt;Has(KEY##_##key) &amp;&amp; !VAR-&gt;Get(KEY##_##key)-&gt;IsString()) { \
    return v8::ThrowException(v8::Exception::Error(v8::String::New("Option \"" #KEY "\" must be a valid string"))); \
}</code></pre>

<h1>define ARG_CHECK_OBJECT_ATTR_UINT32(VAR, KEY) \</h1>

<pre><code>v8::Local&lt;v8::String&gt; KEY##_##key = v8::String::New("" #KEY ""); \
if (!VAR-&gt;Has(KEY##_##key)) { \
    return v8::ThrowException(v8::Exception::Error(v8::String::New("Option \"" #KEY "\" is mandatory"))); \
} else if (!VAR-&gt;Get(KEY##_##key)-&gt;IsUint32()) { \
    return v8::ThrowException(v8::Exception::Error(v8::String::New("Option \"" #KEY "\" must be a valid UINT32"))); \
}</code></pre>

<h1>define ARG_CHECK_OBJECT_ATTR_OPTIONAL_UINT32(VAR, KEY) \</h1>

<pre><code>v8::Local&lt;v8::String&gt; KEY##_##key = v8::String::New("" #KEY ""); \
if (VAR-&gt;Has(KEY##_##key) &amp;&amp; !VAR-&gt;Get(KEY##_##key)-&gt;IsUint32()) { \
    return v8::ThrowException(v8::Exception::Error(v8::String::New("Option \"" #KEY "\" must be a valid UINT32"))); \
}</code></pre>

<h1>define ARG_CHECK_OBJECT_ATTR_BOOL(VAR, KEY) \</h1>

<pre><code>v8::Local&lt;v8::String&gt; KEY##_##key = v8::String::New("" #KEY ""); \
if (!VAR-&gt;Has(KEY##_##key)) { \
    return v8::ThrowException(v8::Exception::Error(v8::String::New("Option \"" #KEY "\" is mandatory"))); \
} else if (!VAR-&gt;Get(KEY##_##key)-&gt;IsBoolean()) { \
    return v8::ThrowException(v8::Exception::Error(v8::String::New("Option \"" #KEY "\" must be a valid boolean"))); \
}</code></pre>

<h1>define ARG_CHECK_OBJECT_ATTR_OPTIONAL_BOOL(VAR, KEY) \</h1>

<pre><code>v8::Local&lt;v8::String&gt; KEY##_##key = v8::String::New("" #KEY ""); \
if (VAR-&gt;Has(KEY##_##key) &amp;&amp; !VAR-&gt;Get(KEY##_##key)-&gt;IsBoolean()) { \
    return v8::ThrowException(v8::Exception::Error(v8::String::New("Option \"" #KEY "\" must be a valid boolean"))); \
}</code></pre>

<h1>define ARG_CHECK_OBJECT_ATTR_FUNCTION(VAR, KEY) \</h1>

<pre><code>v8::Local&lt;v8::String&gt; KEY##_##key = v8::String::New("" #KEY ""); \
if (!VAR-&gt;Has(KEY##_##key)) { \
    return v8::ThrowException(v8::Exception::Error(v8::String::New("Option \"" #KEY "\" is mandatory"))); \
} else if (!VAR-&gt;Get(KEY##_##key)-&gt;IsFunction()) { \
    return v8::ThrowException(v8::Exception::Error(v8::String::New("Option \"" #KEY "\" must be a valid function"))); \
}</code></pre>

<h1>define ARG_CHECK_OBJECT_ATTR_OPTIONAL_FUNCTION(VAR, KEY) \</h1>

<pre><code>v8::Local&lt;v8::String&gt; KEY##_##key = v8::String::New("" #KEY ""); \
if (VAR-&gt;Has(KEY##_##key) &amp;&amp; !VAR-&gt;Get(KEY##_##key)-&gt;IsFunction()) { \
    return v8::ThrowException(v8::Exception::Error(v8::String::New("Option \"" #KEY "\" must be a valid function"))); \
}</code></pre>

<h1>endif  // SRC_DRIZZLE_BINDINGS_H_</h1>
</td>
<td class="code">

</td>
</tr><tr class="filename"><td><h2 id="./src/drizzle_bindings.cc"><a href="#">drizzle_bindings.cc</a></h2></td><td>./src/drizzle_bindings.cc</td></tr><tr class="code">
<td class="docs">
<p>// Copyright 2011 Mariano Iglesias <a href="mailto:mgiglesias@gmail.com">mgiglesias@gmail.com</a>
#include "./drizzle_bindings.h"
#include "./drizzle.h"</p>

<p>extern "C" {
    void init(v8::Handle&lt;v8::Object&gt; target) {
        node_drizzle::Drizzle::Init(target);
    }</p>

<pre><code>NODE_MODULE(drizzle_bindings, init);</code></pre>

<p>}</p>
</td>
<td class="code">

</td>
</tr><tr class="filename"><td><h2 id="./drizzle.js"><a href="#">drizzle</a></h2></td><td>./drizzle.js</td></tr>	</body>
</html></tbody></table>